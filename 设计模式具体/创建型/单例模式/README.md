# 单例模式
解决了2个问题，违反了 单一职责 原则
1. 保证一个类只有一个实例
2. 为该实例提供一个全局访问节点

## 适用场景

1. 程序中每个类对应所有客户端只有一个可用的实例
2. 需要更加严格的控制全局变量，随时调整

## 实现方式
1. 在类中添加一个私有静态成员变量用于保存单例实例
2. 申明一个公有静态构建方法用于获取单例实例
3. 在静态方法中实现"延迟初始化"，首次调用创建一个新对象，并保存在
静态成员变量中，此后每次都返回。
4. 将类的构造函数设为私有，类的静态方法可以调用构造函数，其他对象不能
5. 检查客户端代码，将对单例的构造函数的调用替换成对其静态构建方法的调用。

### 优点
1. 一个类只有一个实例。
2. 获得指向该实例的全局访问节点。
3. 首次请求该单例对象时进行初始化

### 缺点
1. 违反单一职责，解决2个问题
2. 可以掩盖不良设计，比如程序组件间互相了解过多。
3. 在多线程下需要特殊处理，避免多个线程多次创建单例对象
4. 客户端单元测试比较困难，测试框架基于继承来创建模拟对象。
单例的构造函数是私有的。

## 与其他模式的关系

1. 外观模式通常可以转换为单例模式
2. 如果能把对象的所有共享状态简化为一个享元对象，那么享元模式和单例类似了，
但是两个模式有两个根本的不同。
    > 1.只会有一个单例实体,但是享元模式可以有多个实体，内在状态可以不同
    > 2.单体对象可以是可变的,享元对象是不可变的   

3. 抽象工厂模式、生成器模式和原型模式都可以用单例来实现                                                                                      